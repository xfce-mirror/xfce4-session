#!/bin/sh
#
#  xfce4
#
#  Copyright (C) 2015, 2018 Simon SteinbeiÃŸ (simon@xfce.org)
#  Copyright (C) 2014..2021 Jarno Suni (8@iki.fi)
#
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 2 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software
#  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
#
set -eu
unset -v IFS

# Sleep time given in decimal number $1. The unit is second.
# Try to do that even in a system in which sleep command does not
# support non-integer time.
real_sleep() {
	# The default sleep might not accept non-integer argument
	sleep "$1" || perl -e "select(undef, undef, undef, $1)" \
	|| sleep "$(( ${1%%.*} + 1 ))" # in case perl is not installed
	# and non-integer sleep is supported, determine time by ceiling
	# function to get at least given amount of delay.
} 2>/dev/null

# Turn off display after given time in seconds.
initial_dpms() {
	sleep "$1"
	xset dpms force $DPMS_MODE
}

# Set trap for EXIT and signals whose default action is abnormal
# termination (T) in table found at
# https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/signal.h.html
set_trap() {
	for c in EXIT ALRM HUP INT PIPE POLL PROF TERM USR1 USR2 VTALRM; do
		eval trap -- \'$1\' $c 2>/dev/null || :
	done
}

# Run command with DPMS, if wanted.
# First argument is boolean one telling, if this should touch DPMS setting.
# The second argument is the shell command string to run.
command_dpms() {
	set_dpms="$1"
	[ "$set_dpms" = true ] && {
		# Save the state of DPMS; rely on the output format of `xset q`.
		xstate=$(xset q | awk '/^DPMS /{getline;
			printf "%s %s %s ", $2, $4, $6; getline;
			if($3=="Enabled"){print "+"}else{print "-"}exit}')
		revert() {
			set_trap -
			xset dpms ${xstate}dpms
		}
		set_trap 'revert; exit'
		# Set monitor power management
		xset dpms $dpms_string
	}
	error_code=0
	# Use explicit error detection so that possible bash sh reverts on
	# success when this function is running in background/subshell.
	/bin/sh -c "$2" || error_code=$?
	[ "$set_dpms" = true ] && revert
	return $error_code
}

# Wait a bit so that user have time to raise finger from a key if
# the script is run in terminal.
[ -t 0 ] && real_sleep 0.5

default() {
	printf 'Using default value %s.\n' "$1" >&2
	printf %s "$1"
}

# get unsigned integer value
DPMS_INITIAL_DELAY=$(xfconf-query -c xfce4-session \
-p /general/LockInitialDelayDPMS || default 1)

# get unsigned integer value
DPMS_DELAY=$(xfconf-query -c xfce4-session \
-p /general/LockDelayDPMS || default 15)

# get string
DPMS_MODE=$(xfconf-query -c xfce4-session -p /general/LockModeDPMS \
|| default off)
case "$DPMS_MODE" in
	standby) dpms_string="$DPMS_DELAY 0 0";;
	suspend) dpms_string="0 $DPMS_DELAY 0";;
	off) dpms_string="0 0 $DPMS_DELAY";;
	*) printf 'Invalid DPMS mode: %s
Allowed values are standby, suspend and off\n' "$DPMS_MODE" >&2; exit 1
esac

# Use a custom lock command, if given.
LOCK_CMD=$(xfconf-query -c xfce4-session -p /general/LockCommand || :)
[ -n "$LOCK_CMD" ] && {
	# Get boolean value to decide whether or not to apply display
	# power management :
	LOCK_SET_DPMS=$(xfconf-query -c xfce4-session \
	-p /general/LockSetDPMS || default false)
	# Get another boolean value to tell, if the LOCK_CMD forks or not.
	# If it forks (i.e. the value is "true") this script can not apply
	# display power management and the setting above is ignored except
	# for turning display off initially.
	LOCK_FORKS=$(xfconf-query -c xfce4-session \
	-p /general/LockCommandForks || default false)
	exit_code=0;
	[ "$LOCK_FORKS" = true ] && {
		command_dpms false "$LOCK_CMD" || exit_code=$?
	} || {
		command_dpms "$LOCK_SET_DPMS" "$LOCK_CMD" &
		pid=$!
		sleep 1 & # wait at most a second
		pid_sleep=$!
		# Test, if command_dpms is running after small delay.
		while kill -0 "$pid" 2>/dev/null; do
			kill -0 "$pid_sleep" 2>/dev/null || {
				# command_dpms still running after the maximum delay.
				# Suppose LOCK_CMD locked.
				[ "$LOCK_SET_DPMS" = true ] \
				&& initial_dpms $((DPMS_INITIAL_DELAY > 1 \
				? DPMS_INITIAL_DELAY - 1 : 0)) &
				exit 0
			}
			real_sleep 0.1 # Take a breath
		done

		# command_dpms finished; get the exit code
		exit_code=0; wait "$pid" || exit_code=$?
	}

	[ "$exit_code" -eq 0 ] && {
		# Suppose LOCK_CMD forked and screen is locked.
		[ "$LOCK_SET_DPMS" = true ] \
		&& initial_dpms $DPMS_INITIAL_DELAY &
		exit 0
	}
	>&2 printf "'%s' exited with error %s\n" "$LOCK_CMD" "$exit_code"
	exit 1
}

for lock_cmd in \
	xfce4-screensaver \
	xscreensaver \
	light-locker
do
	# To redirect stdin to /dev/null is needed at least for xscreensaver
	# to not have 1 s delay when invoked on terminal.
	${lock_cmd}-command --lock </dev/null 2>/dev/null && exit
done

# 'gnome-screensaver-command --lock' always returns 0 even if it does
# not lock. (Version 3.6.1 at least.)
# Thus running with '--query' first is needed.
[ -n "$(gnome-screensaver-command --query 2>/dev/null)" ] \
&& gnome-screensaver-command --lock </dev/null 2>/dev/null
