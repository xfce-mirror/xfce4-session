#!/bin/sh
#
#  xfce4
#
#  Copyright (C) 2015, 2018 Simon SteinbeiÃŸ (simon@xfce.org)
#  Copyright (C) 2014..2021 Jarno Suni (8@iki.fi)
#
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 2 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software
#  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
#
set -eu
unset -v IFS

# find a free file descriptor
FD=3; while { >&$FD; } 2>/dev/null; do FD=$((FD+1)); done

# get string
DEBUG=$(xfconf-query -c xfce4-session -p /general/LockDebugFile || :)
[ -n "$DEBUG" ] && {
	exec >"$DEBUG" 2>&1
	eval "exec $FD>&1"
	set -x
} || eval "exec $FD>/dev/null"

# Sleep time given in decimal number $1. The unit is second.
# Try to do that even in a system in which sleep command does not
# support non-integer time.
real_sleep() {
	# The default sleep might not accept non-integer argument
	sleep "$1" || perl -e "select(undef, undef, undef, $1)" \
	|| sleep "$(( ${1%%.*} + 1 ))" # in case perl is not installed
	# and non-integer sleep is supported, determine time by ceiling
	# function to get at least given amount of delay.
} 2>&$FD

# Turn off display after given time in seconds.
initial_dpms() {
	sleep "$1"
	xset dpms force $DPMS_MODE
}

# Set trap for EXIT and signals whose default action is abnormal
# termination (T) in table found at
# https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/signal.h.html
set_trap() {
	for c in EXIT ALRM HUP INT PIPE POLL PROF TERM USR1 USR2 VTALRM; do
		eval trap -- \'$1\' $c 2>&$FD || :
	done
}

# Run command with DPMS, if wanted.
# First argument is boolean one telling, if this should touch DPMS setting.
# The second argument is the shell command string to run.
command_dpms() {
	set_dpms="$1"
	[ "$set_dpms" = true ] && {
		# Save the state of DPMS; rely on the output format of `xset q`.
		xstate=$(xset q | awk '/^DPMS /{getline;
			printf "%s %s %s ", $2, $4, $6; getline;
			if($3=="Enabled"){print "+"}else{print "-"}exit}')
		revert() {
			set_trap -
			xset dpms ${xstate}dpms
		}
		set_trap 'revert; exit'
		# Set monitor power management
		xset dpms $dpms_string
	}
	error_code=0
	# Use explicit error detection so that possible bash sh reverts on
	# success when this function is running in background/subshell.
	/bin/sh -c "$2" || error_code=$?
	[ "$set_dpms" = true ] && revert
	return $error_code
}

# Wait a bit so that user have time to raise finger from a key if
# the script is run in terminal.
[ -t 0 ] && real_sleep 0.5

default() {
	printf 'Using default value %s.\n' "$1" >&2
	printf %s "$1"
}

run_xdg_screensaver_lock() {
	name=xdg-screensaver # try to lock by this utility
	if cmd=$(command -v "$name"); then
		# ensure it is a shell script
		read -r line <"$cmd"
		[ "$line" = '#!/bin/sh' ] \
		|| {
			printf 'Error: %s is not a shell script\n' "$cmd" >&2
			return 1
		}
		[ "$DEBUG" ] && { x=x; level=3; } || { x=''; level=0; }
		# Source $cmd in shell to get the shell trace for debugging
		ret=0
		env XDG_UTILS_DEBUG_LEVEL=$level sh -c$x '
			[ "$1" ] || exec 2>/dev/null
			shift; printf "#### START DEBUG INSIDE FILE %s\n" "$0" >&2
			. "$0"
		' "$cmd" "$x" lock </dev/null || ret=$?
		[ "$x" ] && printf '#### END DEBUG INSIDE FILE %s\n' "$cmd" >&2
		return "$ret"
	else
		printf "Command '%s' not found.\n" "$name" >&2
		return 1
	fi
}

# get unsigned integer value
DPMS_INITIAL_DELAY=$(xfconf-query -c xfce4-session \
-p /general/LockInitialDelayDPMS || default 1)

# get unsigned integer value
DPMS_DELAY=$(xfconf-query -c xfce4-session \
-p /general/LockDelayDPMS || default 15)

# get string
DPMS_MODE=$(xfconf-query -c xfce4-session -p /general/LockModeDPMS \
|| default off)
case "$DPMS_MODE" in
	standby) dpms_string="$DPMS_DELAY 0 0";;
	suspend) dpms_string="0 $DPMS_DELAY 0";;
	off) dpms_string="0 0 $DPMS_DELAY";;
	*) printf 'Invalid DPMS mode: %s
Allowed values are standby, suspend and off\n' "$DPMS_MODE" >&2; exit 1
esac

# Use a custom lock command, if given.
LOCK_CMD=$(xfconf-query -c xfce4-session -p /general/LockCommand || :)
[ -n "$LOCK_CMD" ] && {
	# Get boolean value to decide whether or not to apply display
	# power management :
	LOCK_SET_DPMS=$(xfconf-query -c xfce4-session \
	-p /general/LockSetDPMS || default false)
	# Get another boolean value to tell, if the LOCK_CMD forks or not.
	# If it forks (i.e. the value is "true") this script can not apply
	# display power management and the setting above is ignored except
	# for turning display off initially.
	LOCK_FORKS=$(xfconf-query -c xfce4-session \
	-p /general/LockCommandForks || default false)
	exit_code=0;
	[ "$LOCK_FORKS" = true ] && {
		command_dpms false "$LOCK_CMD" || exit_code=$?
	} || {
		command_dpms "$LOCK_SET_DPMS" "$LOCK_CMD" &
		pid=$!
		sleep 1 & # wait at most a second
		pid_sleep=$!
		# Test, if command_dpms is running after small delay.
		while kill -0 "$pid" 2>/dev/null; do
			kill -0 "$pid_sleep" 2>/dev/null || {
				# command_dpms still running after the maximum delay.
				# Suppose LOCK_CMD locked.
				[ "$LOCK_SET_DPMS" = true ] \
				&& initial_dpms $((DPMS_INITIAL_DELAY > 1 \
				? DPMS_INITIAL_DELAY - 1 : 0)) &
				exit 0
			}
			real_sleep 0.1 # Take a breath
		done

		# command_dpms finished; get the exit code
		exit_code=0; wait "$pid" || exit_code=$?
	}

	[ "$exit_code" -eq 0 ] && {
		# Suppose LOCK_CMD forked and screen is locked.
		[ "$LOCK_SET_DPMS" = true ] \
		&& initial_dpms $DPMS_INITIAL_DELAY &
		exit 0
	}
	>&2 printf "'%s' exited with error %s\n" "$LOCK_CMD" "$exit_code"
	exit 1
}

for lock_cmd in \
	xfce4-screensaver \
	xscreensaver \
	light-locker
do
	# To redirect stdin to /dev/null is needed at least for xscreensaver
	# to not have 1 s delay when invoked on terminal.
	${lock_cmd}-command --lock </dev/null 2>&$FD && exit
done

run_xdg_screensaver_lock
